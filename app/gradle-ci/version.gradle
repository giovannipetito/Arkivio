/**
 * Increments the ARKIVIO_VERSION in the build.gradle file according to the provided 'scope' and 'increment'.
 * Then it also creates a commit for the changed version.
 */
static def incrementVersion(project, git, String versionStr, String scope, int increment) {
    assert ["snapshot", "dev", "patch", "minor", "major"].contains(scope)
    assert increment > 0

    final LazyVersion version = new LazyVersion(versionStr)
    println "currentVersion = $version, scope = ${scope}, increment = ${increment}"

    final String newVersionStr

    switch (scope) {
        case "patch":
            version.incrementPatch(increment)
            newVersionStr = version.toString()
            break
        case "minor":
            version.incrementMinor(increment)
            newVersionStr = version.toString()
            break
        case "major":
            version.incrementMajor(increment)
            newVersionStr = version.toString()
            break
        case "dev":
//            version.incrementPatch(increment)
            newVersionStr = "${version.toString()}-dev_${project.createHeadCommitId()}"
            break
        case "snapshot":
//            version.incrementMinor(increment)
            newVersionStr = "${version.toString()}-snapshot_${project.createHeadCommitId()}"
            break
        default:
            println "nothing to do for scope $scope"
            return
    }

    println "newVersion = $newVersionStr"

    def buildFile = project.rootProject.buildFile
    def s = buildFile.getText().replaceFirst("ARKIVIO_VERSION = \"$versionStr\"", "ARKIVIO_VERSION = \"$newVersionStr\"")
    buildFile.setText(s)

    if (scope == "snapshot" || scope == "dev") {
//        println "ARKIVIO_VERSION change is only temporary for release candidates -> don't commit"
        println "No ARKIVIO_VERSION update for Dev/Test releases -> don't commit"
        return
    }

    def branch = null
    try {
        branch = System.getenv('CI_BUILD_REF_NAME')
    } catch (ignored) {
        // ignored
    }

    if (branch != null) {
        // in case of gitlab ci build we have to check out and update the branch to be able to commit and push afterwards
        // to be sure we have no merge conflicts while updating the local branch, we have to delete the local branch and
        // recreate it
        if (git.branch.list().find { it.name == branch }) {
            git.branch.remove(names: [branch], force: true)
        }
        git.checkout(branch: branch, startPoint: "origin/$branch", createBranch: true)

        // fetch remote tags, and prune local tags that doesn't exist on remote
        "git tag -l | xargs git tag -d && git fetch -t".execute().waitForOrKill(5000)
    }

    git.add(patterns: ['build.gradle'])
    git.commit(message: "Version $newVersionStr")
}

class LazyVersion {
    int major
    int minor
    int patch

    LazyVersion(String versionName) {
        def matcher = versionName.trim() =~ /^([0-9]+)\.([0-9]+)\.([0-9]+)$/
        assert matcher.groupCount() == 3
        def group = matcher[0]

        this.major = group[1].toInteger()
        this.minor = group[2].toInteger()
        this.patch = group[3].toInteger()
    }

    LazyVersion(int major, int minor, int patch) {
        this.major = major
        this.minor = minor
        this.patch = patch
    }

    void incrementMajor(int increment) {
        assert increment > 0
        major = major + increment
        minor = 0
        patch = 0
    }

    void incrementMinor(int increment) {
        assert increment > 0
        minor = minor + increment
        patch = 0
    }

    void incrementPatch(int increment) {
        assert increment > 0
        patch = patch + increment
    }

    @Override
    String toString() {
        return "$major.$minor.$patch"
    }
}

ext {
    incrementVersion = this.&incrementVersion
}
